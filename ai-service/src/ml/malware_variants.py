"""
Malware modality routing, validation, and model caching (Phase A foundation).

Variants (keys match model_registry.json under models.malware.variants):
 - windows_api_seq
 - pe_sections (optional, may be disabled)
 - pe_imports
 - android_apk
 - net_flow_79 (current model uses 39 features; see registry note)
"""

from __future__ import annotations

import threading
from collections import OrderedDict
from typing import Optional, Dict, Tuple

import numpy as np

from ..logging import get_logger
from ..utils.errors import ValidationError


VARIANT_KEYS = {
    'api_seq': 'windows_api_seq',
    'pe': 'pe_imports',         # default to imports; sections can be enabled later
    'apk': 'android_apk',
    'net_flow': 'net_flow_79',  # name per plan (actual model currently 39 features)
}


class ModalityRouter:
    """Map artifact modality to malware variant key."""

    def __init__(self):
        self._logger = get_logger(__name__)

    def route(self, modality: str) -> Optional[str]:
        if not modality:
            return None
        m = modality.strip().lower()
        return VARIANT_KEYS.get(m)


class MalwareModelCache:
    """
    Thread-safe LRU cache over malware variant models, using ModelRegistry.
    """

    def __init__(self, registry, capacity: int = 3):
        self._registry = registry
        self._capacity = max(int(capacity), 1)
        self._cache: OrderedDict[str, object] = OrderedDict()
        self._lock = threading.RLock()
        self._logger = get_logger(__name__)

    def get(self, variant_key: str):
        with self._lock:
            if variant_key in self._cache:
                self._cache.move_to_end(variant_key)
                return self._cache[variant_key]
        # load outside lock to avoid long critical section
        model = self._registry.load_malware_variant(variant_key)
        if model is None:
            return None
        with self._lock:
            self._cache[variant_key] = model
            self._cache.move_to_end(variant_key)
            while len(self._cache) > self._capacity:
                evicted_key, _ = self._cache.popitem(last=False)
                self._logger.info(f"Evicted malware model from cache: {evicted_key}")
        return model

    def expected_feature_count(self, variant_key: str) -> Optional[int]:
        """Read expected feature_count from registry metadata."""
        try:
            models = self._registry.registry.get('models', {})
            malware = models.get('malware', {})
            variants = malware.get('variants', {})
            meta = variants.get(variant_key)
            if not meta or 'feature_count' not in meta:
                return None
            try:
                n = int(meta.get('feature_count'))
                return n if n > 0 else None
            except Exception:
                return None
        except Exception:
            return None


def validate_variant_features(variant_key: str, x: np.ndarray, expected_count: Optional[int]) -> None:
    """
    Strict validation for variant feature vectors. Raises ValidationError on violation.
    """
    if not isinstance(x, np.ndarray):
        raise ValidationError(f"features must be numpy.ndarray, got {type(x)}")
    if x.ndim != 1:
        raise ValidationError(f"features must be 1-D vector, got shape {x.shape}")
    if expected_count is not None and x.shape[0] != expected_count:
        raise ValidationError(
            f"feature length mismatch for {variant_key}: expected {expected_count}, got {x.shape[0]}"
        )
    if not np.all(np.isfinite(x)):
        raise ValidationError("features contain non-finite values (NaN/Inf)")
