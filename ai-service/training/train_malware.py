"""
Train LightGBM model for malware detection (PE features).

256-dimensional feature vector based on EMBER dataset format.
"""

import sys
import json
import hashlib
from pathlib import Path
from datetime import datetime

import numpy as np
import joblib
from sklearn.model_selection import train_test_split
from sklearn.calibration import CalibratedClassifierCV
from sklearn.metrics import classification_report, roc_auc_score, confusion_matrix
import lightgbm as lgb

project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from src.utils.signer import Signer
from src.logging import get_logger

logger = get_logger(__name__)


def load_synthetic_malware_data():
    """Generate synthetic malware features (256-dim)."""
    logger.info("Generating synthetic malware dataset...")
    
    np.random.seed(43)
    n_benign = 4000
    n_malware = 2000
    
    # Benign PE files (normal entropy, imports, sections)
    X_benign = np.random.randn(n_benign, 256) * 0.5
    X_benign[:, :10] = np.random.uniform(3, 6, (n_benign, 10))  # Normal entropy
    y_benign = np.zeros(n_benign)
    
    # Malware (higher entropy, obfuscation, suspicious imports)
    X_malware = np.random.randn(n_malware, 256) * 1.5
    X_malware[:, :10] = np.random.uniform(6.5, 8, (n_malware, 10))  # High entropy
    X_malware[:, 10:20] += 2  # Suspicious API calls
    y_malware = np.ones(n_malware)
    
    X = np.vstack([X_benign, X_malware])
    y = np.hstack([y_benign, y_malware])
    
    indices = np.random.permutation(len(X))
    X, y = X[indices], y[indices]
    
    logger.info(f"Generated {X.shape[0]} samples: {np.sum(y==1)} malware, {np.sum(y==0)} benign")
    return X, y


def main():
    logger.info("="*60)
    logger.info("TRAINING MALWARE DETECTION MODEL")
    logger.info("="*60)
    
    X, y = load_synthetic_malware_data()
    X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.4, random_state=42, stratify=y)
    X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)
    
    # Train
    n_benign = np.sum(y_train == 0)
    n_malware = np.sum(y_train == 1)
    scale_pos_weight = n_benign / n_malware
    
    model = lgb.LGBMClassifier(
        objective='binary',
        metric='auc',
        num_leaves=31,
        max_depth=7,
        learning_rate=0.05,
        n_estimators=100,
        scale_pos_weight=scale_pos_weight,
        random_state=42,
        verbose=-1
    )
    model.fit(X_train, y_train, eval_set=[(X_val, y_val)], eval_metric='auc')
    
    # Calibrate
    calibrated = CalibratedClassifierCV(model, method='sigmoid', cv='prefit')
    calibrated.fit(X_val, y_val)
    
    # Evaluate
    y_pred = calibrated.predict(X_test)
    y_proba = calibrated.predict_proba(X_test)[:, 1]
    auc = roc_auc_score(y_test, y_proba)
    tn, fp, fn, tp = confusion_matrix(y_test, y_pred).ravel()
    fpr = fp / (fp + tn) if (fp + tn) > 0 else 0.0
    tpr = tp / (tp + fn) if (tp + fn) > 0 else 0.0
    
    logger.info(f"Performance - AUC: {auc:.4f}, FPR: {fpr:.4f}, TPR: {tpr:.4f}")
    print(classification_report(y_test, y_pred, target_names=['Benign', 'Malware']))
    
    # Save
    models_dir = project_root / 'data' / 'models'
    model_path = models_dir / 'malware_lgbm_v1.0.0.pkl'
    joblib.dump(calibrated, model_path)
    logger.info(f"Model saved: {model_path}")
    
    # Sign
    keys_dir = project_root / 'keys'
    signer = Signer(str(keys_dir / 'signing_key.pem'), key_id='model_signing_key', domain_separation='model.v1')
    model_bytes = model_path.read_bytes()
    fingerprint = hashlib.sha256(model_bytes).hexdigest()
    signature, _, _ = signer.sign(model_bytes)
    (model_path.with_suffix('.pkl.sig')).write_bytes(signature)
    logger.info(f"Model signed: {fingerprint}")
    
    # Update registry
    registry_path = models_dir / 'model_registry.json'
    registry = json.loads(registry_path.read_text())
    registry['models']['malware_lgbm'] = {
        'version': '1.0.0',
        'path': 'malware_lgbm_v1.0.0.pkl',
        'fingerprint': fingerprint,
        'algorithm': 'LightGBM',
        'calibration': 'sigmoid',
        'performance': {'auc': float(auc), 'fpr': float(fpr), 'tpr': float(tpr), 'tp': int(tp), 'fp': int(fp), 'tn': int(tn), 'fn': int(fn)},
        'trained_at': datetime.utcnow().isoformat() + 'Z',
        'feature_count': 256,
        'threat_type': 'malware'
    }
    registry_path.write_text(json.dumps(registry, indent=2))
    logger.info("Registry updated")
    logger.info("="*60)
    logger.info(f"COMPLETE! AUC: {auc:.4f}, FPR: {fpr:.4f}")
    logger.info("="*60)


if __name__ == '__main__':
    main()
